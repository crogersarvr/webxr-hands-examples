<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js vr - handinput</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

  <div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - handinput<br />
    (Oculus Browser with #webxr-hands flag enabled)
  </div>

  <script type="module">

    import * as THREE from './libs/three.module.js';
    import { VRButton } from './jsm/webxr/VRButton.js';
    import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';
    import { XRHandModelFactory } from './jsm/webxr/XRHandModelFactory.js';
    import { OculusHandModel } from './js/OculusHandModel.js';
    import { BasicButtonMesh } from './js/BasicButton.js';
    import { createText } from './js/Text2D.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

    const FRAME_RATE = 72;
    const ROTATION_INCREMENT = Math.PI / (FRAME_RATE * 4);
    const SCALE_FACTOR = 0.1;

    let container;
    let camera, scene, renderer;
    let hand1, hand2;
    let handModel1, handModel2;
    let rocketObject, consoleObject;
    let buttons = [];
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    let xrSession;

    init();
    animate();


    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x444444);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
      camera.position.set(0, 1.6, 3);


      const floorGeometry = new THREE.PlaneGeometry(4, 4);
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = - Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

      // buttons
      let yawIncButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      yawIncButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.z += ROTATION_INCREMENT;
      });
      buttons.push(yawIncButton);
      let yawSubButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      yawSubButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.z -= ROTATION_INCREMENT;
      });
      buttons.push(yawSubButton);
      let rollIncButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      rollIncButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.y += ROTATION_INCREMENT;
      });
      buttons.push(rollIncButton);
      let rollSubButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      rollSubButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.y -= ROTATION_INCREMENT;
      });
      buttons.push(rollSubButton);
      let pitchIncButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      pitchIncButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.x += ROTATION_INCREMENT;
      });
      buttons.push(pitchIncButton);
      let pitchSubButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffffff, 0x696969);
      pitchSubButton.setWhilePressedAction(function () {
        let rot = rocketObject.rotation;
        rocketObject.rotation.x -= ROTATION_INCREMENT;
      });
      buttons.push(pitchSubButton);

      let scaleUpButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xffff00, 0x696969);
      scaleUpButton.setOnPressAction(function () {
        rocketObject.scale.multiplyScalar(1 + SCALE_FACTOR);
      });
      buttons.push(scaleUpButton);
      let scaleDownButton = new BasicButtonMesh(0.065, 0.065, 0.065, 0xff0000, 0x696969);
      scaleDownButton.setOnPressAction(function () {
        rocketObject.scale.multiplyScalar(1 - SCALE_FACTOR);
      });
      buttons.push(scaleDownButton);

      let exitButton = new BasicButtonMesh(0.12, 0.065, 0.065, 0xff0000, 0x696969);
      exitButton.setOnPressAction(function () {
        renderer.xr.getSession().end();
      });
      buttons.push(exitButton);

      let text = createText("exit", 0.06);
      text.position.set(0,0,0.033);
      exitButton.add(text);

      const loader = new GLTFLoader();
      // Load a glTF resource
      loader.load(
        // resource URL
        './models/SpaceShuttle/SpaceShuttle.glb',
        // called when the resource is loaded
        function (gltf) {

          rocketObject = gltf.scene.children[0];
          rocketObject.position.set(0, 0, -5);
          scene.add(rocketObject);
        }
      );

      loader.load(
        // resource URL
        './models/ControlConsole/ControlConsole.glb',
        // called when the resource is loaded
        function (gltf) {

          consoleObject = new THREE.Object3D();
          let consoleModel = gltf.scene.children[0];
          consoleModel.scale.set(3, 3, 3);
          consoleObject.add(consoleModel);
          consoleObject.position.set(0, 1, -0.5);

          consoleObject.add(yawIncButton);
          yawIncButton.position.set(0, 0.025, 0.08);
          yawIncButton.geometry.computeBoundingBox();

          consoleObject.add(yawSubButton);
          yawSubButton.position.set(0, 0.025, 0.17);
          yawSubButton.geometry.computeBoundingBox();

          consoleObject.add(rollIncButton);
          rollIncButton.position.set(-0.09, 0.025, 0.08);
          rollIncButton.geometry.computeBoundingBox();

          consoleObject.add(rollSubButton);
          rollSubButton.position.set(-0.09, 0.025, 0.17);
          rollSubButton.geometry.computeBoundingBox();

          consoleObject.add(pitchIncButton);
          pitchIncButton.position.set(-0.18, 0.025, 0.08);
          pitchIncButton.geometry.computeBoundingBox();

          consoleObject.add(pitchSubButton);
          pitchSubButton.position.set(-0.18, 0.025, 0.17);
          pitchSubButton.geometry.computeBoundingBox();

          consoleObject.add(scaleUpButton);
          scaleUpButton.position.set(0.09, 0.025, 0.08);
          scaleUpButton.geometry.computeBoundingBox();

          consoleObject.add(scaleDownButton);
          scaleDownButton.position.set(0.09, 0.025, 0.17);
          scaleDownButton.geometry.computeBoundingBox();

          consoleObject.add(exitButton);
          exitButton.position.set(0.2, -0.02, 0.23);
          exitButton.geometry.computeBoundingBox();

          scene.add(consoleObject);
        }
      );

      const light = new THREE.DirectionalLight(0xffffff);
      light.position.set(0, 6, 0);
      light.castShadow = true;
      light.shadow.camera.top = 2;
      light.shadow.camera.bottom = - 2;
      light.shadow.camera.right = 2;
      light.shadow.camera.left = - 2;
      light.shadow.mapSize.set(4096, 4096);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;

      container.appendChild(renderer.domElement);

      document.body.appendChild(VRButton.createButton(renderer));

      // controllers

      controller1 = renderer.xr.getController(0);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      scene.add(controller2);

      const controllerModelFactory = new XRControllerModelFactory();

      // Hand 1
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      hand1 = renderer.xr.getHand(0);
      handModel1 = new OculusHandModel(hand1);
      hand1.add(handModel1);

      scene.add(hand1);

      // Hand 2
      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      hand2 = renderer.xr.getHand(1);
      handModel2 = new OculusHandModel(hand2);
      hand2.add(handModel2);
      scene.add(hand2);

      //

      const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 1)]);

      const line = new THREE.Line(geometry);
      line.name = 'line';
      line.scale.z = 5;

      controller1.add(line.clone());
      controller2.add(line.clone());

      //

      window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }
    //

    function animate() {

      renderer.setAnimationLoop(render);

    }

    function render() {
      for (let button of buttons) {
        if (handModel1.intersectBoxObject(button) || handModel2.intersectBoxObject(button)) {
          button.onPress();
        } else {
          button.onClear();
        }
        if (button.isPressed()) {
          button.whilePressed();
        }
      }
      renderer.render(scene, camera);
    }

  </script>
</body>

</html>
